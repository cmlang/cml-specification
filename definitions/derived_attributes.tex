A \emph{concept} in CML may have \emph{attributes} (\ref{ch:attributes})
that do not hold specific \emph{values},
but instead provide a \emph{value} derived from an \emph{expression} (\ref{ch:expressions}).
These are called \emph{derived attributes}.
Unlike an \emph{expression} used to initialize a \emph{non-derived attribute},
the \emph{expression} of a \emph{derived attribute} is evaluated
every time the \emph{value} of an \emph{attribute} is fetched.

In the UML \cite{uml} metamodel,
the \emph{Property} metaclass has a meta-attribute named \emph{isDerived},
which determines whether an \emph{attribute} is derived or not.
A \emph{derived attribute} in UML may be defined using a OCL \cite{ocl} constraint;
while CML has \emph{expressions} as part of the language.

The ER \cite{er} metamodel,
in its original form,
does not allow for the differentiation of \emph{derived attributes}
as part of an \emph{entity set},
but it is possible to define \emph{retrieval operations} whose 
results would equal to \emph{values} of \emph{derived properties} in CML.
It can be said, however, that ER,
by defining an \emph{attribute} as a function from the \emph{entity set}
to the \emph{value set},
does not prescribe that all \emph{attributes} are memory-based,
nor does it prevent the definition of an \emph{attribute} function 
as an \emph{expression}.

The CML metamodel and its syntax, on the other hand,
define whether an \emph{attribute} is memory-based (a \emph{non-derived attribute})
or it is derived from an \emph{expression} (a \emph{derived attribute}).

\begin{examples}
Figure \ref{fig:ex:attributes} presents two examples of \emph{derived attributes}
declared in CML.
As shown,
the attribute \textbf{c} is derived from an \emph{expression}
that refers to other \emph{attributes}.
In order to differentiate \emph{attributes} with initial values,
such as \textbf{b},
from \emph{derived attributes},
such as \textbf{c},
a forward slash (``/'') prefixes the name of the latter.
The attribute \textbf{e} is an example of a \emph{derived attribute}
where the type is inferred from the given \emph{expression},
instead of being specified.
\end{examples}

\begin{concrete-syntax}
Figure \ref{fig:stx:property} specifies the syntax used
to declare any kind of \emph{property} (\ref{sec:properties}),
including \emph{derived attributes}.
A \emph{derived attribute} must be prefixed with the forward-slash character,
as specified by DERIVED,
in which case the given \emph{expression} provides the value
of the \emph{attribute} every time it is fetched.
\end{concrete-syntax}

\begin{abstract-syntax}
The \emph{property} metaclass in the CML metamodel is used to represent
\emph{attributes}.
Figure \ref{fig:meta:property} presents the \emph{property} metaclass
in an EMOF \cite{mof} class diagram,
and figure \ref{fig:ast:property} specifies
the \emph{property} transformation
from its concrete syntax to its abstract syntax.
The \emph{derived} property of the \emph{Property} metaclass
defines whether the \emph{attribute} is derived or not.
\end{abstract-syntax}
