context Type::numeric: Boolean
def: 
    types = Set {
        'Byte' 'Short' 'Integer' 'Long'
        'Float' 'Double'
        'Decimal'
    }
derive:
    types->includes(self.name)

context Type::isWiderThan(Type other): Boolean
def: 
    types = Sequence {
        'Byte' 'Short' 'Integer' 'Long'
        'Float' 'Double'
        'Decimal'
    }
pre:
    self.numeric and other.numeric
post:
    result = 
        types->indexOf(self.name) > types->indexOf(other.name)

context Type::isTypeAssignableFrom(Type other): Boolean
post:
    if self.name = other.name then
        result = true
    else if self.concept->notEmpty() and 
            other.concept->notEmpty() 
         then
            result = other.concept.all_generalizations
                        ->exists(name = self.concept.name)    
    else if self.numeric and other.numeric then
        result = self.isWiderThan(other)
    else
        result = false

context Type::isCardinalityAssignableFrom(Type other): Boolean
post:
    result = (self.cardinality = other.cardinality) or
             (self.cardinality = '*') or
             (self.cardinality = '?')

context Type::isAssignableFrom(Type other): Boolean
post:
    result = self.isTypeAssignableFrom(other) and
             self.isCardinalityAssignableFrom(other)

