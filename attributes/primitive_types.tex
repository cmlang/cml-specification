\begin{definition}
A \emph{primitive type} in CML is one of the pre-defined \emph{data types}
supported by the language,
as shown in tables \ref{tab:core-primitive-types} and \ref{tab:additional-primitive-types}.
In the ER \cite{er} metamodel,
a \emph{data type} is formally defined as a \emph{set} of \emph{values}
that can be held by an \emph{attribute} (\ref{ch:attributes}).
The original ER paper \cite{er} states that,
for each \emph{value set} (i.e. \emph{data type}),
there is a \emph{predicate} that can be used to test
whether a \emph{value} belongs to the \emph{set}.
In CML, instead,
\emph{literal expressions} are syntactically defined for each \emph{primitive type},
so that the \emph{type} can be inferred from the \emph{literal expression}.
On the original ER paper,
it is also said that \emph{values} in a \emph{value set}
may be equivalent to \emph{values} in another \emph{value set}.
In CML, also,
\emph{literal expressions} of the \emph{Integer} type may be equivalent 
to \emph{literal expressions} of the \emph{Decimal},
and so with other \emph{ordinal types}.
This allows \emph{expressions} of a \emph{primitive type}
to be promoted to \emph{expressions} of another \emph{primitive type}
in order to allow \emph{type inference} of composite \emph{expressions},
such as \emph{infix expressions} (\ref{sec:infix}).
In the UML \cite{uml} metamodel,
there is a specific metaclass named \emph{PrimitiveType},
which matches to the same notion in CML.
\end{definition}

\begin{table}[h]
\centering
\begin{tabular}
{l l l l l p{2cm} }
\hline
CML & Java & C\# & C++ & Python & TypeScript (JavaScript) \\
\hline
String & String & string & std::wstring & str & string \\
\multicolumn{6}{p{13cm}}{\footnotesize{16-bit Unicode character sequences.}} \\
\\
Boolean & boolean & bool & bool & bool & boolean \\
\multicolumn{6}{p{13cm}}{\footnotesize{Only values are the literal expressions: \textbf{true}, \textbf{false}.}}  \\
\\
Integer & int & int & int32\_t & int & number  \\
\multicolumn{6}{p{13cm}}{\footnotesize{32-bit signed two's complement integer.}}  \\
\\
Decimal* & BigDecimal & decimal & decimal128 & Decimal & number \\
\multicolumn{6}{p{13cm}}{\footnotesize{Arbitrary precision arithmetic, as provided by the target language.}} \\
\\
\multicolumn{6}{p{13cm}}{*The specification of Decimal type varies by target programming language;
compared to floating-point types, the Decimal type has more precision,
making it appropriate for monetary calculations.}
\end{tabular}
\caption{Core Primitive Types in CML.}
\label{tab:core-primitive-types}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}
{l l l l l p{2cm} p{3.5cm} }
\hline
CML & Java & C\# & C++ & Python & TypeScript (JavaScript) & Specification \\
\hline
Byte & byte & byte & int8\_t & int & number & 8-bit signed two's complement integer \\
Short & short & short & int16\_t & int & number & 16-bit signed two's complement integer \\
Long & long & long & int64\_t & long & number & 64-bit signed two's complement integer \\
Float & float & float & float* & float & number & 32-bit IEEE 754 floating point \\
Double & double & double & double* & float & number & 64-bit IEEE 754 floating point \\
\\
\multicolumn{7}{p{12cm}}{*C++ floating point types may vary by hardware and compiler}
\end{tabular}
\caption{Additional Primitive Types in CML.}
\label{tab:additional-primitive-types}
\end{table}

\begin{examples}
Figure \ref{fig:ex:primitive-types} presents examples
of \emph{atributes} declared with \emph{primitive types} in CML.
Each example corresponds to one of the \emph{primitive types} 
supported by the language,
as shown in tables \ref{tab:core-primitive-types} and \ref{tab:additional-primitive-types}.
The CML's base module will translate the primitive types to Java, C\#, and C/C++,
according to the tables.
All numberic types will be translated to Number in TypeScript. 

\end{examples}

\begin{figure}
\verbatimfont{\small}
\lstinputlisting[language=cml]{examples/primitive_types.cml}
\caption{Example of \emph{Primitive Types}}
\label{fig:ex:primitive-types}
\end{figure}
