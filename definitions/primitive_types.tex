A \emph{primitive type} in CML is one of the pre-defined \emph{data types}
supported by the language,
as shown in tables \ref{tab:core-primitive-types} and \ref{tab:additional-primitive-types}.

In the ER \cite{er} metamodel,
a \emph{data type} is formally defined as a \emph{set} of \emph{values}
that can be held by an \emph{attribute} (\ref{ch:attributes}).
The original ER paper \cite{er} states that,
for each \emph{value set} (i.e. \emph{data type}),
there is a \emph{predicate} that can be used to test
whether a \emph{value} belongs to the \emph{set}.
In CML, instead,
\emph{literal expressions} are syntactically defined for each \emph{primitive type},
so that the \emph{type} can be inferred from the \emph{literal expression}.

On the original ER paper,
it is also said that \emph{values} in a \emph{value set}
may be equivalent to \emph{values} in another \emph{value set}.
In CML, also,
\emph{literal expressions} of the \emph{Integer} type may be equivalent
to \emph{literal expressions} of the \emph{Decimal},
and so with other \emph{numeric types}.
This allows \emph{expressions} (\ref{ch:expressions}) of a \emph{primitive type}
to be promoted to \emph{expressions} of another \emph{primitive type}
in order to allow \emph{type inference} of composite \emph{expressions}.

In the UML \cite{uml} metamodel,
there is a specific metaclass named \emph{PrimitiveType},
which matches to the same notion in CML.

\begin{table}[h]
\centering
\begin{tabular}
{l l l l l p{2cm} }
\hline
CML & Java & C\# & C++ & Python & TypeScript (JavaScript) \\
\hline
String & String & string & std::wstring & str & string \\
\multicolumn{6}{p{13cm}}{\footnotesize{16-bit Unicode character sequences.}} \\
\\
Boolean & boolean & bool & bool & bool & boolean \\
\multicolumn{6}{p{13cm}}{\footnotesize{Only values are the literal expressions: \textbf{true}, \textbf{false}.}}  \\
\\
Integer & int & int & int32\_t & int & number  \\
\multicolumn{6}{p{13cm}}{\footnotesize{32-bit signed two's complement integer.}}  \\
\\
Decimal* & BigDecimal & decimal & decimal128 & Decimal & number \\
\multicolumn{6}{p{13cm}}{\footnotesize{Arbitrary precision,
fixed-point,
or decimal floating-point,
depending on the target language.}} \\
\\
\multicolumn{6}{p{13cm}}{*The specification of Decimal type varies by target programming language.
Compared to the binary floating-point types (Float and Double),
the Decimal type is better suited for monetary calculations
at a performance cost.}
\end{tabular}
\caption{Core Primitive Types in CML.}
\label{tab:core-primitive-types}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}
{l l l l l p{2cm} p{3.5cm} }
\hline
CML & Java & C\# & C++ & Python & TypeScript (JavaScript) & Specification \\
\hline
Byte & byte & byte & int8\_t & int & number & 8-bit signed two's complement integer \\
Short & short & short & int16\_t & int & number & 16-bit signed two's complement integer \\
Long & long & long & int64\_t & long & number & 64-bit signed two's complement integer \\
Float & float & float & float* & float & number & 32-bit IEEE 754 binary floating point \\
Double & double & double & double* & float & number & 64-bit IEEE 754 binary floating point \\
\\
\multicolumn{7}{p{12cm}}{*C++ floating point types may vary by hardware and compiler}
\end{tabular}
\caption{Additional Primitive Types in CML.}
\label{tab:additional-primitive-types}
\end{table}
