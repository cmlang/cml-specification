\begin{definition}
A \emph{concept} in CML may have \emph{attributes} (\ref{ch:attributes})
that do not hold specific \emph{values},
but instead provide a \emph{value} derived from an \emph{expression} (\ref{ch:expressions}).
These are called \emph{derived attributes}.
Unlike an \emph{expression} used to initialize a regular \emph{attribute},
the \emph{expression} of a \emph{derived attribute} is evaluated
every time the \emph{value} of an \emph{attribute} is fetched.
In the UML \cite{uml} metamodel,
the \emph{Property} metaclass has a meta-attribute named \emph{isDerived},
which determines whether an \emph{attribute} is derived or not.
A \emph{derived attribute} in UML may be defined using a OCL \cite{ocl} constraint,
while CML has \emph{expressions} as part of the language.
The ER \cite{er} metamodel,
in its original form,
does not allow for the differentiation of \emph{derived attributes}
as part of an \emph{entity set},
but it is possible to define \emph{retrieval operations} whose 
results would equal to \emph{values} of \emph{derived properties} in CML.
It can be said, however, that ER,
by defining an \emph{attribute} as a function from the \emph{entity set}
to the \emph{value set},
does not prescribe that all \emph{attributes} are memory-based,
nor does it prevent the definition of the \emph{attribute} function 
as an \emph{expression}.
The CML metamodel and its syntax, on the other hand,
define whether an \emph{attribute} is memory-based (a \emph{non-derived attribute})
or it is derived from an \emph{expression} (a \emph{derived attribute}).
\end{definition}
