\begin{definition}
A \emph{property} in CML may hold values of primitive types,
in which case they correspond to \emph{attributes}
on the ER \cite{er} and UML \cite{uml} metamodels;
or they may hold references (or collections of references)
linking to instances of other \emph{concepts},
in which case they correspond to a \emph{relationship} on the ER metamodel,
and to \emph{associations} on the UML metamodel.
\end{definition}

\begin{examples}
Figure \ref{fig:ex:properties} presents some examples of \emph{properties} declared in CML.
As shown in the examples,
a \emph{property} may be an \emph{attribute} (\ref{ch:attributes})
of a \emph{primitive type} (\ref{sec:primitive-types}),
or represent the role/end of an \emph{association} (\ref{ch:associations}).
\end{examples}

\begin{figure}
\verbatimfont{\small}
\lstinputlisting[language=cml]{examples/properties.cml}
\caption{Property Examples}
\label{fig:ex:properties}
\end{figure}

\begin{concrete-syntax}
Figure \ref{fig:stx:property} specifies the syntax used
to declare a \emph{property}.
The NAME is followed by a \emph{typeDeclaration}
(\ref{sec:primitive-types} and \ref{sec:collection-types}).
Optionally, an \emph{expression} (\ref{ch:expressions}) may be specified
in order to set the initial value.
\end{concrete-syntax}

\begin{figure}
\verbatimfont{\small}
\lstinputlisting[language=antlr]{grammar/Properties.txt}
\caption{Property Declaration Syntax}
\label{fig:stx:property}
\end{figure}

\begin{abstract-syntax}
Figure \ref{fig:meta:property} presents the \emph{Property} metaclass
in an EMOF \cite{mof} class diagram of the CML metamodel,
and figure \ref{fig:ast:property} specifies
the transformation
from the \emph{property} concrete syntax to its abstract syntax.
For each \emph{property} parsed by the compiler,
an instance of the \emph{Property} class will be created,
and its properties will be assigned
according to parsed information:

\begin{itemize}

\item \emph{name}:
assigned with the value of the terminal node NAME.

\item \emph{type}:
if \emph{typeDeclaration} is provided,
\emph{type} is set with the instance of the \emph{Type} class
matching the \emph{typeDeclaration}.

\item \emph{expression}:
if provided,
it contains the instance of the \emph{Expression} class
matching the parsed \emph{expression}.

\end{itemize}
\end{abstract-syntax}

\begin{figure}
\verbatimfont{\small}
\lstinputlisting[language=lsl]{ast/property.lsl}
\caption{Property AST Instantiation}
\label{fig:ast:property}
\end{figure}

\begin{constraints}
Figure \ref{fig:ocl:property} presents the invariants
of the \emph{Property} metaclass:

\begin{itemize}

\item \emph{unique\_property\_name}:
Each \emph{property} must have a unique NAME within its \emph{concept}
(\ref{ch:concepts}).

\item \emph{property\_type\_specified\_or\_inferred}:
Either the \emph{property} explicitly defines a \emph{type}
or it defines an \emph{expression},
from which the type is inferred.
That is required for both regular, slot-based \emph{properties}
(which may provide an \emph{initialization expression})
and \emph{derived properties}
(which may have an \emph{expression} defining the derivation).

\item \emph{property\_type\_assignable\_from\_expression\_type}:
When both a \emph{type} and \emph{expression} are defined for a \emph{property},
the \emph{type} inferred from the \emph{expression} should be assignable to
the declared \emph{type}.
That is required for both regular, slot-based \emph{properties}
(which may provide an \emph{initialization expression})
and \emph{derived properties}
(which may have an \emph{expression} defining the derivation).

\end{itemize}
\end{constraints}

\begin{figure}
\lstinputlisting[language=ocl_]{ocl/property.ocl}
\caption{Property Constraints}
\label{fig:ocl:property}
\end{figure}
